diff -dNur a/build/depends.py b/build/depends.py
--- a/build/depends.py	2015-12-01 17:29:47.731520477 +0000
+++ b/build/depends.py	2015-12-01 17:34:59.412854685 +0000
@@ -403,39 +403,15 @@
     SOUNDTOUCH_PATH = 'soundtouch-1.8.0'
 
     def sources(self, build):
-        return ['engine/enginebufferscalest.cpp',
-                '#lib/%s/AAFilter.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/BPMDetect.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/FIFOSampleBuffer.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/FIRFilter.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/InterpolateCubic.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/InterpolateLinear.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/InterpolateShannon.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/PeakFinder.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/RateTransposer.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/SoundTouch.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/TDStretch.cpp' % self.SOUNDTOUCH_PATH,
-                # SoundTouch CPU optimizations are only for x86
-                # architectures. SoundTouch automatically ignores these files
-                # when it is not being built for an architecture that supports
-                # them.
-                '#lib/%s/cpu_detect_x86.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/mmx_optimized.cpp' % self.SOUNDTOUCH_PATH,
-                '#lib/%s/sse_optimized.cpp' % self.SOUNDTOUCH_PATH]
+        return ['engine/enginebufferscalest.cpp']
 
     def configure(self, build, conf, env=None):
         if env is None:
             env = build.env
-        env.Append(CPPPATH=['#lib/%s' % self.SOUNDTOUCH_PATH])
-
-        # Prevents circular import.
-        from features import Optimize
-
-        # If we do not want optimizations then disable them.
-        optimize = (build.flags['optimize'] if 'optimize' in build.flags
-                    else Optimize.get_optimization_level(build))
-        if optimize == Optimize.LEVEL_OFF:
-            env.Append(CPPDEFINES='SOUNDTOUCH_DISABLE_X86_OPTIMIZATIONS')
+        if not conf.CheckLib(['SoundTouch','libSoundTouch']):
+            raise Exception('Did not find SoundTouch library, exiting!')
+        build.env.Append(CPPPATH=[SCons.ARGUMENTS.get('prefix') + '/include/soundtouch'])
+        build.env.Append(LIBS='SoundTouch')
 
 
 class RubberBand(Dependence):
diff -dNur a/build/features.py b/build/features.py
--- a/build/features.py	2015-12-01 17:29:47.731520477 +0000
+++ b/build/features.py	2015-12-01 17:40:15.398209140 +0000
@@ -45,7 +45,6 @@
 
 
 class HID(Feature):
-    HIDAPI_INTERNAL_PATH = '#lib/hidapi-0.8.0-rc1'
 
     def description(self):
         return "HID controller support"
@@ -62,10 +61,6 @@
     def configure(self, build, conf):
         if not self.enabled(build):
             return
-        # TODO(XXX) allow external hidapi install, but for now we just use our
-        # internal one.
-        build.env.Append(
-            CPPPATH=[os.path.join(self.HIDAPI_INTERNAL_PATH, 'hidapi')])
 
         if build.platform_is_linux:
             build.env.ParseConfig(
@@ -90,25 +85,17 @@
 
         build.env.Append(CPPDEFINES='__HID__')
 
+        if not conf.CheckLib('hidapi-libusb'):
+            raise Exception('Did not find HID API library, exiting!')
+        build.env.Append(CPPPATH=[SCons.ARGUMENTS.get('prefix') + '/include/hidapi'])
+        build.env.Append(LIBS='hidapi-libusb')
+
+
     def sources(self, build):
-        sources = ['controllers/hid/hidcontroller.cpp',
+        return ['controllers/hid/hidcontroller.cpp',
                    'controllers/hid/hidenumerator.cpp',
                    'controllers/hid/hidcontrollerpresetfilehandler.cpp']
 
-        if build.platform_is_windows:
-            # Requires setupapi.lib which is included by the above check for
-            # setupapi.
-            sources.append(
-                os.path.join(self.HIDAPI_INTERNAL_PATH, "windows/hid.c"))
-        elif build.platform_is_linux:
-            # hidapi compiles the libusb implementation by default on Linux
-            sources.append(
-                os.path.join(self.HIDAPI_INTERNAL_PATH, 'libusb/hid.c'))
-        elif build.platform_is_osx:
-            sources.append(
-                os.path.join(self.HIDAPI_INTERNAL_PATH, 'mac/hid.c'))
-        return sources
-
 
 class Bulk(Feature):
     def description(self):
@@ -745,25 +732,16 @@
             test_env.Append(CCFLAGS='-pthread')
             test_env.Append(LINKFLAGS='-pthread')
 
-        test_env.Append(CPPPATH="#lib/gtest-1.7.0/include")
-        gtest_dir = test_env.Dir("#lib/gtest-1.7.0")
-        # gtest_dir.addRepository(build.env.Dir('#lib/gtest-1.5.0'))
-        # build.env['EXE_OUTPUT'] = '#/lib/gtest-1.3.0/bin'  # example,
-        # optional
-        test_env['LIB_OUTPUT'] = '#/lib/gtest-1.7.0/lib'
-
-        env = test_env
-        SCons.Export('env')
-        env.SConscript(env.File('SConscript', gtest_dir))
-
-        # build and configure gmock
-        test_env.Append(CPPPATH="#lib/gmock-1.7.0/include")
-        gmock_dir = test_env.Dir("#lib/gmock-1.7.0")
-        # gmock_dir.addRepository(build.env.Dir('#lib/gmock-1.5.0'))
-        test_env['LIB_OUTPUT'] = '#/lib/gmock-1.7.0/lib'
 
-        env.SConscript(env.File('SConscript', gmock_dir))
+        if not conf.CheckLib('gtest'):
+            raise Exception('Did not find gtest library, exiting!')
+        test_env.Append(CPPPATH=[SCons.ARGUMENTS.get('prefix') + '/include/gtest'])
+        test_env.Append(LIBS='gtest')
 
+        if not conf.CheckLib('gmock'):
+            raise Exception('Did not find gmock library, exiting!')
+        test_env.Append(CPPPATH=[SCons.ARGUMENTS.get('prefix') + '/include/gmock'])
+        test_env.Append(LIBS='gmock')
         return []
 
 
